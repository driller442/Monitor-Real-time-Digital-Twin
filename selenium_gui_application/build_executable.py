import PyInstaller.__main__
import os
import shutil
import sys

def get_absolute_path(relative_path):
    # Assumes build_executable.py is in the project root C:\Projects\selenium_gui_application
    base_dir = os.path.dirname(os.path.abspath(__file__))
    return os.path.normpath(os.path.join(base_dir, relative_path))

APP_NAME = "element_finder_app"
SCRIPT_FILE = os.path.join("src", "gui_app.py") # Relative to project root

# Paths for PyInstaller
# Path to the 'src' directory, to help find modules like 'utils'
SRC_DIR_PATH = get_absolute_path("src") 

# Path to the dark_theme.css file and its destination in the bundle
DARK_THEME_CSS_SOURCE = get_absolute_path(os.path.join("src", "resources", "styles", "dark_theme.css"))
DARK_THEME_CSS_DEST_IN_BUNDLE = os.path.join("resources", "styles") # Destination relative to app's root in bundle

# Check if source files exist
script_abs_path = get_absolute_path(SCRIPT_FILE)
if not os.path.exists(script_abs_path):
    print(f"ERROR: Main script '{script_abs_path}' not found.")
    sys.exit(1)
if not os.path.exists(DARK_THEME_CSS_SOURCE):
    print(f"ERROR: CSS file '{DARK_THEME_CSS_SOURCE}' not found.")
    sys.exit(1)

print("============================================================")
print(f"{APP_NAME} - PyInstaller Builder (Updated v2)")
print("============================================================")

# Clean previous builds
dist_dir = get_absolute_path("dist")
build_dir = get_absolute_path("build")
spec_file_generated_name = get_absolute_path(f"{APP_NAME}.spec") # PyInstaller generates this

if os.path.exists(dist_dir):
    print(f"Cleaning up old '{dist_dir}' directory...")
    shutil.rmtree(dist_dir)
if os.path.exists(build_dir):
    print(f"Cleaning up old '{build_dir}' directory...")
    shutil.rmtree(build_dir)
if os.path.exists(spec_file_generated_name): # Remove spec file if generated by PyInstaller previously
    print(f"Cleaning up old '{spec_file_generated_name}' file...")
    os.remove(spec_file_generated_name)

# PyInstaller arguments
pyinstaller_args = [
    script_abs_path,  # Use absolute path for the main script
    '--name={}'.format(APP_NAME),
    '--onefile',
    # '--windowed', # Temporarily disabled for console debugging # Use --console instead of --windowed for easier debugging of ModuleNotFound errors
    '--console', # ENABLED FOR DEBUGGING
    
    # Crucial for finding modules within the 'src' directory (like 'utils')
    '--paths={}'.format(SRC_DIR_PATH), 
    
    '--add-data={}{}{}'.format(DARK_THEME_CSS_SOURCE, os.pathsep, DARK_THEME_CSS_DEST_IN_BUNDLE),
    
    # Common hidden import that can sometimes be needed by packages like 'requests' or others.
    # Add if specific 'No module named pkg_resources.py2_warn' errors appear.
    # '--hidden-import=pkg_resources.py2_warn', 
]

# Add selenium_element_finder.py. If it's imported, PyInstaller *should* find it.
# If not, or if it's loaded dynamically, add it as data.
# For now, assume it's imported correctly by script_runner.py.
# Example if needed:
# SELENIUM_SCRIPT_SOURCE = get_absolute_path(os.path.join("src", "selenium_element_finder.py"))
# SELENIUM_SCRIPT_DEST_IN_BUNDLE = "." # Place in root of bundle
# if os.path.exists(SELENIUM_SCRIPT_SOURCE):
#    pyinstaller_args.append('--add-data={}{}{}'.format(SELENIUM_SCRIPT_SOURCE, os.pathsep, SELENIUM_SCRIPT_DEST_IN_BUNDLE))
# else:
#    print(f"WARNING: selenium_element_finder.py not found at {SELENIUM_SCRIPT_SOURCE}, not adding as data.")


# Attempt to add an icon if present (Windows specific example)
icon_path_win = get_absolute_path(os.path.join("src", "resources", "app.ico")) 
if sys.platform.startswith('win') and os.path.exists(icon_path_win):
    pyinstaller_args.append('--icon={}'.format(icon_path_win))
else:
    if sys.platform.startswith('win'):
        print(f"Note: Windows Icon file not found at '{icon_path_win}', building without custom icon.")

print("\nRunning PyInstaller with arguments:")
for arg in pyinstaller_args:
    print(f"  {arg}")
print("\nThis may take a few minutes...\n")

try:
    PyInstaller.__main__.run(pyinstaller_args)
    print("\n============================================================")
    print("PyInstaller build process completed.")
    final_exe_path = os.path.join(dist_dir, f"{APP_NAME}.exe" if sys.platform.startswith('win') else APP_NAME)
    print(f"Executable should be in: {final_exe_path}")
    if not os.path.exists(final_exe_path):
        print(f"ERROR: Expected executable not found at {final_exe_path} after build!")
    print("============================================================")
except Exception as e:
    print("\n============================================================")
    print(f"AN ERROR OCCURRED DURING PYINSTALLER EXECUTION: {e}")
    print("Make sure all dependencies listed in requirements.txt AND any specific checks in this script are met.")
    print("============================================================")
    sys.exit(1)
else:
    # Verify the executable was created
    final_exe_path = os.path.join(dist_dir, f"{APP_NAME}.exe" if sys.platform.startswith('win') else APP_NAME)
    if not os.path.exists(final_exe_path):
        print(f"POST-BUILD ERROR: PyInstaller reported success, but executable not found at {final_exe_path}!")
        sys.exit(1)

